# Props Drilling
# ContextAPI / Recoil / Zustand - Props Drilling 을 해결하기 위한 방법
# 오늘 계획
1. React Form 처리
2. TypeScript
3. React 기반 RESTful API 작성(cardatabase 연동)

## React Form 처리
- HTML / CSS 수업 할 때 오렌지가 어쩌고 하면서 form 처리와 관련된 부분을 다뤘다. React에선 약간 차이가 있는데 HTML 양식은 제출되면(submit이 이뤄지면) 다음 페이지로 이동한다. React 에선 제출 후 폼 데이터에 접근할 수 있는 JS 함수를 호출하고 다음 페이지로의 이동을 방지하고 싶은 경우가 흔히 있다.(SPA니까.) .preventDefault()를 이용해 제출 자체를 피하는 방법을 어제 마지막으로 다뤘다.

1. App.jsx에 MyForm만 배치

이후 input 하나와 button 하나가 있는 최소한의 폼을 생성하고 입력한 field의 값을 가져오기 위해 onChange 이벤트 핸들러를 다룰 예정

useState() 훅을 활용해 text라는 상태 변수를 하나 생성할거다. 그래서 input 필드의 값이 변경되면 새 값이 상태에 _갱신_ 될 수 있도록 작성할거다.

이 MyForm 컴포넌트는 폼 데이터가 리액트에 의해 처리되기 때문에 _제어 컴포넌트_ 라고 불린다.

제어되지 않는 컴포넌트에서 폼 데이터는 DOM에 의해서만 처리될거다.

setText(event.target.value); 문을 통해 input field에서 값을 가져와서 상태에 저장하고 제출 버튼을 눌렀을 때 입력한 값을 alret로 띄울거다.
이하는 예시.
```jsx
import { useState } from "react";

function MyForm() {
  const [ text, setText ] = useState('');

  // input field에 입력한 것을 submit하면 날려 보낼 수 있도록 하는 함수 작성
  const handleChange = (event) => {
    setText(event.target.value);
    console.log(text);
  }
  const handleInputChange = (event) => {
    alert(`'${text}' 라고 입력 하셨습니다.`);
    event.preventDefault();
  }
  return (
    <form onSubmit={handleInputChange}>
      <input type="text" onChange={handleChange} value={text}/>
      <br />
      <br />
      <input type="submit" value='클릭하세요 😊' />
    </form>
  );
}
export default MyForm
```
이상에서 어제 내용과 헷갈릴 수 있는데 상태가 업뎃된다고 매번 리렌더링이 일어나는 것은 아님. 상태의 변화를 감지해 리렌더링을 일으키기 위한 Hook은 useEffect()였다.

## React Developer Tools 확인법 수업했다.
f12 눌러서 Components로 들가면 현재 작성한 코드 상에서의 Hook들을 확인 가능. MyForm을 기준으로 했을 때 text라는 상태 하나 밖에 없기 때문에

hooks
1. State : "안녕하세요"

를 확인 가능했다.

그럼 다수의 상태를 확인하는 부분을 체크하겠다.
1. MyForm3.jsx 생성 -> 초기화
2. App.jsx에 MyForm3 import

todolist 때문에 하나짜리 input으로 작성해서 글치 대부분 경우 입력 form엔 입력 field가 복수로 이뤄져있다. 그럼 각각의 상태를 선언하는 방법도 있겠지만 객체를 이용해 처리하는 방법도 있을거다. MyForm3 에서 이를 검증할게.

이하는 예시
```jsx

```
JS 객체 에서 특정 value를 참조하는 방법
1. 객체명.키
  - console.log(person.firstName);
2. 객체명.['키']
  - console.log(person['firstName']);

그럼 lastName과 email에 대한 부분 작성하고 맨 마지막에 input type='submit' 까지 적용해서 input 창에 firstName / lastName 입력 후에 제출 버튼 눌러 alert 띄워라.

### 과제
1. MyForm4.jsx 생성
2. App3.jsx 만들어서 기존 부분 복사 App.jsx 초기화 한 다음 MyForm4만 import
3. MyForm3를 참조하는데 상태를 각각 선언하고 MyForm3과 동일하게 기능할 수 있도록 코드 작성
  - 즉 user 상태가 아니라 firstName / lastName / email 을 별개로 상태 선언 한 후에 코드 작성
  - 이상의 경우 onChange에 대한 부분에서 변화 생길 수 있다. 이를 염두에 둔 상태로 코드 작성

# TypeScript
- TypeScript는 MS에서 개발한 타입 시스템을 제공하는 JS 상위 집합에 해당함.
최근에 인기가 늘어나고 있는 중이고 22년 기준으로 가장 빠르게 성장하는 프로그래밍 언어로 선정됨.

- 특징
1. 변수, 함수, 클래스에 대한 _자료형_ 을 정의 할 수 있다. 이를 통해 개발 프로세스 초기에 오류를 포착하는 것이 가능.
2. 앱의 확장성을 향상시킬 수도 있고 코드를 더 쉽게 유지 관리할 수 있게 해줌.
3. 코드 가독성이 향상되고 코드 자체 문서화가 더 쉽다.

타입스크립트 작성용 웹 IDE 사이트 : https://www.typescriptlang.org/play

## 공통 타입
- TS는 변수를 초기화 할 때 변수의 타입을 자동으로 정의하는데 이를 _타입 추론_ 이라 함.
```ts
let message = '안녕하세요';     
// string 자료형이라고 ts가 타입 추론을 한다.
message = 1;
```
message에 string 값을 대입했을 때 ts는 해당 변수의 자료형이 string이라고 지가 알아서 타입 추론을 한다. 근데 다음 줄에서 message 변수에 number 자료형을 대입하니까 오류 메시지가 떴다(JS에선 상관없다)

TS의 기본 타입은 JS와 동일
1. string : 문자열
2. number : 숫자
3. bool : boolean

근데 TS가 매번 암시적으로 타입 추론을 하게끔 하는 것이 아니라 명시적 타입 설정을 하는 것도 가능.
- 명시적 타입 설정 방법
```ts
let email : string;
email = 3;
// 이상에서 주목해야 할 점은 email이 number 자료형으로 초기화가
// 됐음에도 불구하고 오류가 떴다는 점이다.
let age : number;
let isActive : boolean;

let email : string;
let age : number;
let isActive : boolean;

email = 'a@test.com';
age = 1;
// 변수의 자료형 확인
console.log(typeof email);      // 결과값 : string
console.log(typeof age === 'string');   // 결과값 : false
```
근데 변수의 타입을 모르는 경우도 있을 수 있다. 예를 들어 외부 소스로부터 값을 받아올 때는 명확한 자료형을 모를 수도 있다.
```ts
let externalValue : unknown;
```
* 참조 : TS 에선 any 라는 자료형도 존재함. any 타입을 이용해 변수를 정의하는 경우는 TS가 해당 변수에 대해 타입 검사 또는 추론을 아예 하지 않는다(즉 기존의 JS처럼 사용이 가능함.) 근데 이건 TS를 사용하지 않겠다고 하는 거랑 다를 바가 없다보니 가능한 any는 안쓰는 것을 추천함.

- 배열Array : JS 에서 동일한 방식으로 선언할 수 있긴 한데 배열의 element들의 자료형을 정의해야 한다.
```ts
let arrayOfNums : number[] = [1,2,3,4,5];
let animals : string[] = ['Dog', 'Cat', 'Tiger'];

let arrayOfNums2 : Array<number> = [9,8,7,6];
let animals2 : Array<string> = ['개', '고양이', '호랑이'];
```
- 또한 객체 Object에서도 각각의 property에 대해 타입 추론을 지가 알아한다.
```ts
const student = {
  id : 1,
  name : '김일',
  email : 'kim1@test.com'
}
```
라고 했을 때 student.id의 자료형은 number, student.name / student.email 의 자료형은 string 이라고 지가 알아서 추론 한다는 거다.

근데 이 부분도 미리 통제를 하고 싶다면 interface

```ts
// interface 이용 사례
interface Student {
    id : number;
    name : string;
    email : string;
};
// 이거 또 JS 처럼 생겼기 때문에 (,) 써서 오류 내는 사람이 많다.
// type 이용 사례
// interface 이용 사례
type Student2 = {
    id : number;
    name : string;
    email : string;
};
// 이상과 같이 Student에 대한 속성에 대한 자료형이 있다고 가정했을 때
// 이를 다 모아둔 Student를 자료형으로 또 쓸 수 있다.

const myStudent : Student = {
    id : 1,
    name : '김일',
    email : 'kim1@test.com'
};
// id : '1', 로 쓰면 오류 발생
```
그리고 Java에서의 와일드 카드에 해당하는 `?` 도 있다. 선택적 속성을 정의할 수 있는데 이는 일종의 생성자 부분과 관련이 있다 볼 수 있다.
```ts
type Student2 = {
    id : number;
    name : string;
    email? : string;
};
// 이상과 같이 Student에 대한 속성에 대한 자료형이 있다고 가정했을 때
// 이를 다 모아둔 Student를 자료형으로 또 쓸 수 있다.

const myStudent : Student2 = {
    id : 1,
    name : '김일',
};

console.log(myStudent.email);   // 결과값 : undefined
```
- 선택적 체이닝 연산자(?.)를 이용하면 오류를 일으키지 않고  null이거나 undefined일 수 있는 객체 속성 및 메서드에 안전하게 접근 가능.
```ts
type Person = {
  name : string;
  email : string;
  address? : {
    street : string;
    city : string;
  }
}

// 객체 생성
const person : Person = {
    name : '김이',
    email : 'kim2@test.com'
}
console.log(person);
// 그럼 오류 생기는 부분
// console.log(person.address.street);
// 그럼 선택적 체이닝을 통해 오류 발생 자체를 억제할 수 있다.
console.log(person.address?.street);    // 결과값 : undefined 이부분에 주목하면 됨.
```
이상의 결과값으로는 undefined가 출력되고 오류는 발생안함.

그럼 이상까지의 상황에서 TS를 적용했을 때의 이점은 기본적으로 JS 상에선 _실행을 시키고 나서야 오류 유무를 확인_ 할 수 있는 반면 TS 상에선 개발 단계에서 (즉, 테스트 / 실전 데이터 입력 이전 단계에서) 예측 가능한 오류를 발생시키지 안흥ㄹ 수 있다는 거다.

- 연산자를 이용한 서로 다른 타입을 병렬로 명시하는 방법
```ts
type InputType = string | number;
// 정의한 타입을 이용
let name1 : InputType = 'Hello';
let age : InputType = 12;
```

```ts
type Fuel = 'disel' | 'gasoline' | 'electric';
type NoOfGears = 5 | 6 | 7;

type Car = {
    brand : string;
    fuel : Fuel;
    gears : NoOfGears;
};

const car1 : Car = {
    brand : '기아',
    fuel : 'disel', // 오타가 나거나 
    gears : 5       // 마찬가지로 5,6,7 이 아닌 다른 숫자가 들어가도 오류
}
```
이상의 예시는 연산자를 이용해 _서로 다른 타입을 처리하는 타입_ 인 유니언 타입(Union Type)을 만드는 것이 가능함.

첫 번째 예시의 경우엔 string 이거나 number일 수 있는 InputType이라는 유니언 타입을 생성

두번째는 특정 string data(disel, gasoline, electric) 이거나 특정 number data(5,6,7)만을 가질 수 있는 유니언 타입인 Fuel / NoOfGears를 생성했다.

일종의 사용자 정의 type 이라 볼 수 있다. Java에서 class를 정의했던 것 처럼.

## 함수
```ts
function sayHello(name : string) {
  console.log('Hello' + name);
}
// 근데 name이 꼭 string이어야만 하냐 혹시 number를 넣어도 되게 하려면
function sayHello(name : string | number) {   // or 연산자 사용
  console.log('Hello' + name);
}

sayHello(1);
sayHello('김일');
```
이상의 경우에선 매개변수의 자료형을 고정시키거나 혹은 복수의 자료형 중에 하나를 선택할 수 있게끔 통제하는 방안을 학습했다.

이하에선 return 타입에 대한 자료형 통제 부분임.
```ts
function calcSum(x : number, y : number) : number {
  return x + y;
}
```
여기까지가 TS 기초 파트

## TypeScript in React
### 상태와 프롭
- 리액트에선 컴포넌트 프롭의 타입을 정의해야한다. 컴포넌트의 프롭이 JS 객체라고 학습을 했었다. 그래서 props.username과 같은 방식으로 호출했었다. 그럼 프롭의 타입을 정의하기 위해선 type 또는 interface를 사용하는 것이 가능할거다.

1. HelloComponent.tsx 생성
2. App.tsx의 내용을 App2.tsx로 복사하고 App.tsx 초기화
3. HelloComponent.tsx를 App.tsx에 import
4. npm run dev 통해서 빈 화면 브라우저에 출력

```tsx
type HelloProps = {
  name: string;
  age: number;
}
function HelloComponent({name, age} : HelloProps) {    // 이건 객체 구조분해 봐야함.
  return (
    <>
      Hello, {name}, you are {age} years old
    </>
  )
}

export default HelloComponent
```
이상의 코드를 해석하기 위해 알아야 하는 개념
1. 객체 구조 분해
2. props drilling
3. props가 JS의 객체라는 점
4. typescript 상에서의 매개변수에 자료형을 통제하는 방법

이상의 코드를 적용하게 되면 age='20'과 같은 방식으로 프롭을 전달하게 됐을 때 오류 메시지를 출력함. jsx의 경우 오류 메시지 자체가 나타나지 않는다. 그럼 이 오류가 드러나는 시점은 age='20' 이라는 string data를 가지고 수학 연산을 시도했을 시점이 돼야 오류를 확인할 수 있게 된다는 점이다.

하지만 TS를 사용했을 경우 미리 경고 메시지를 보내주기 때문에 연산 이전에 수정을 할 수 있따는 점에서 도입할만한 가치가 있다고 할 수 있다.

```tsx
import  HelloProps  from "./types/types.ts"
function HelloComponent({name, age} : HelloProps) {    // 이건 객체 구조분해 봐야함.
  return (
    <>
      Hello, {name}, you are {age} years old
    </>
  )
}
export default HelloComponent
```
이상은 이미 정의한 type을 types/types.ts로 분할하여 import한 예시.
이상과 같이 했을 경우 만약 ByeComponent를 만든다 가정했을 때 거기서도 똑같이 HelloProps를 쓸 수 있다.

ByeComponent를 확인.

근데 이 타입추론이라는 개념이 꼭 TS에서만 사용되는 것이 아니고 표준 리액트 타입인  FC(Function Component)가 있긴함.

예시만 보여줌

```jsx
import React from 'react';
import {HelloProps} from './types/types';

const HelloComponent : React.FC<HelloProps> = ({name, age}) => {
  return (
    <>
      Hello {name}, you are {age} tears old !
    </>
  )
}
```
이상까진 props의 자료형을 통제하는 방식을 학습함.

```jsx
// boolean
const [ isReady, setIsReady ] = useState(false);

// string
const [ message, setMessage ] = useState('');

// number
const [ count, setCount ] = useState(0);
```
이상의 배웠었던 useState 훅을 생각해보면 initialValue 값을 _타입 추론_ 한다는 것을 알 수 있다.

그래서
```jsx
setCount('Hello');
```
와 같은 방식으로 암시적으로 작성된 type과 다른 자료형을 argument로 넣을 경우 오류가 발생함.

근데 TS는 명시적으로 타입을 설정하는 편이라 useState()의 initialValue 의 자료형을 통제하는 것이 가능함.

```tsx
const [ message, setMessage ] = useState<string | undefined>(undefined);
```
이상의 예시는 message의 자료형이 string 이건 undefined로 넣어줄 수 있다.

혹은 아까 배운 방식대로 type / interface를 사용하는 방법도 있다.

```ts
// types.ts
type User = {
  id : number;
  name : string;
  email : string
}
```
```tsx
import { User } from './types.types';

function ExampleComponent() {
  // 타입을 상태와 함께 활용하고자 할 때 초기값으론 아무 것도 담겨 있지 않은 User 객체를 이용
  // const [ user, setUser ] = useState<User>({} as User)
  // 혹은 null값도 허용됨.
  const [ user, setUser ] = useState<User | null>(null);
  return(
    <>
    </>
  );
}
export default ExampleComponent
```

## 


과 같이 정의되있을 때 handleChange의 예시는 이하와 같다.
```tsx
const handleChange = (event) => {
  setName(event.target.value)
}
```
근데 이게 난해한게 handleSubmit 때도 매개변수를 event라 정해줬었다.

event가 특정한 HTML element와 관련이 있다는 점을 명시할 때 사용하는 명령어가 있는데
```tsx
const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  setName(event.target.value);
}
```
그렇다면 form과 관련있는 onSubmit 이벤트 핸들러의 경우엔 어떻게 되냐면
```tsx
const handleSubmit = (event: React.FormEvent<HTMLFormELement>) => {
  event.preventDefault();
  alert(`Hello ${name}`);
}
```
과 같은 방식으로 작성한다. 즉 임의적으로 e 혹은 event로 매개변수 명을 짓기는 하지만 어느 HTML 요소와 관련있는지에 따라 딸려있는 속성(특징)과 메서드가 서로 다르기 때문에 TS상에서는 이를 통제하는 편이다.

전체 종류는
chrome -> typescript cheat sheets를 검색하면 [깃허브 typescript cheat sheets](https://github.com/typescript-cheatsheets/react-typescript-cheatsheet-kr)

## TS로 리액트 앱 만들기
아까 위에 작성한 예시 코드들을 적용한 tsx를 작성함
