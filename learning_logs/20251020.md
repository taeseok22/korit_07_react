# 오늘 수업 계획
1. 서드파티 컴포넌트
  - React date picker 를 통한 서드파티 컴포넌트 설치
  - AG Grid 를 이용한 페이지네이션 및 필터링
  - MUI 컴포넌트 이용 라이브러리를 위한 CSS
2. SpringBoot 연동
# full stack 이후 수업 관련 사항
1. Docker 배포
2. Github 팀 관련 수업
3. AWS 배포

# 새 프로젝트 생성
1. React-TypeScript로 thirdpartyapp 생성
2. App.tsx 초기화

# third party components
chrome -> awesome-react-components
https://github.com/brillout/awesome-react-components

1. 컴포넌트들은 README에서 볼 수 있듯이 npm을 통해 설치 가능.
`npm install component_name@version`
`npm install react-date-picker@10.0.3`
- 설치된 컴포넌트를 리액트 앱에서 제거하는 명령어
`npm uninstall component_name`
`npm uninstall react-date-picker`
- 업데이트가 누락된 컴포넌트들을 전부 다 검색하는 명령어
`npm outdated`
- 업데이트 누락된 컴포넌트들을 일괄 업데이트 하는 명령어
`npm update`
- 모든 프로젝트 의존성 목록 가져오는 명령어
`npm list`

# AG Grid
`npm install ag-grid-community@30.1.0 ag-grid-react@30.1.0`
AG Grid는 리액트 앱을 위한 데이터 그리드 컴포넌트다.
- 스프레드 시트 처럼 데이터를 표시하는데 이용하며 상호작용도 가능.
- 필터링 / 정렬 / 피벗과 같은 기능들을 포함했다.

```tsx
import { useState } from 'react'
import axios from 'axios'
import { AgGridReact } from 'ag-grid-react'
import 'ag-grid-community/styles/ag-grid.css'
import 'ag-grid-community/styles/ag-theme-material.css'
import './App.css'

type Repository = {
  id: string
  full_name: string
  html_url: string
  username: string
}

function App() {
  const [keyword, setKeyword] = useState('')
  const [repodata , setRepoData] = useState<Repository[]>([])

  const handleClick = () => {
    axios.get<{ items: Repository[] }>(`https://api.github.com/search/repositories?q=${keyword}`)
    .then(response => setRepoData(response.data.items))
    .catch(error => console.log(error))
  }

  return (
    <div className="App">
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}>Search</button>
      <div className="ag-theme-material"
      style={{ height: 500, width: 850}}>
        <AgGridReact rowData={repodata} />
      </div>
    </div>
  )
}

export default App
```
```tsx
import { AgGridReact } from 'ag-grid-react'
import 'ag-grid-community/styles/ag-grid.css'
import 'ag-grid-community/styles/ag-theme-material.css'
```
이상의 import 문들은 ag-grid 컴포넌트 자체와 스타일시트를 가지고왔다. 그 중에서도 81번라인은 google에서 권장하는 material style을 갖고왔음을 뜻한다.

그니까 사전 정의 스타일을 가지고 옴으로써 css를 최소화했다.

근데 styles/ag-grid.css를 통해 최소한의 커스터마이징도 할 수 있는데 이를 style={{height:500, width:850}} 으로 처리했다.

그리고 return 문에 AgGridReact 컴포넌트의 추가를 통해 repoData를 가지고 테이블을 작성하려함.

rowData라고 이미 사전에 이름 붙여져 있는 속성에 프롭을 전달했다. (props drilling 개념). rowData는 객체의 배열을 데이터에 넣을 수 있도록 지원한다.

그리고 ag-gird 컴포넌트 자체는 스타일을 정의하는 div element로 꼭 감싸줘야만 하기 때문에
```tsx
  return (
    <div className="App">
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}>Search</button>
      <div className="ag-theme-material"
      style={{ height: 500, width: 850}}>
        <AgGridReact rowData={repodata} />
      </div>
    </div>
  )
```
이상과 같은 return 문이 작성됐다.

그 다음 과정으로 ag-grid에 이용될 컬럼을 정의할거다. 컬럼 정의 객체의 배열에 해당하는 columnDefs라는 상태를 정의할거다. 그리고 ag-grid는 여기에 이용할 수 있는 ColDef 타입을 제공함.(TypeScript로 쓰는 이유) 컬럼 객체에선 필수 field 프롭을 이용해 데이터 접근자를 정의해야하는데 여기선 field 값이 컬럼이 표시해야 하는 REST API 응답 데이터의 속성 이름이 될거다.

```tsx
import { useState } from 'react'
import axios from 'axios'
import { AgGridReact } from 'ag-grid-react'
import 'ag-grid-community/styles/ag-grid.css'
import 'ag-grid-community/styles/ag-theme-material.css'
import './App.css'
import { ColDef, ICellEditorParams } from 'ag-grid-community'

type Repository = {
  id: string
  full_name: string
  html_url: string
  username: string
}

function App() {
  const [keyword, setKeyword] = useState('')
  const [repodata , setRepoData] = useState<Repository[]>([])
  const [columnDefs] = useState<ColDef[]>([
    {field: 'id', sortable: true, filter: true},        // 컬럼1
    {field: 'full_name', sortable: true, filter: true}, // 컬럼2
    {field: 'html_url', sortable: true, filter: true},  // 컬럼3
    {field: 'full_name', cellRenderer: (params: ICellEditorParams) => {
      <button onClick={() => alert(params.value)}>
        Press Me!
      </button>
    }}
  ])

  const handleClick = () => {
    axios.get<{ items: Repository[] }>(`https://api.github.com/search/repositories?q=${keyword}`)
    .then(response => setRepoData(response.data.items))
    .catch(error => console.log(error))
  }

  return (
    <div className="App">
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}>Search</button>
      <div className="ag-theme-material"
      style={{ height: 500, width: 850}}>
        <AgGridReact rowData={repodata} columnDefs={columnDefs} pagination={true} paginationPageSize={5}/>
      </div>
    </div>
  )
}

export default App
```
이상에서 컬럼의 정의 및 거기에 딸려있는 properties를 확인했다. sortable / filter 였고 그 다음 추가적인 컬럼을 정의했는데 거기에 cellRenderer라는 속성이였다.

그리고 pagenation / pagenamtionPageSize는 `<AgGridReact>` 컴포넌트 내부에 정의했었다. return문과 colDefs 상태를 둘 다 잘 확인 ㄱㄱ

celRenderer 프롭을 이용하면 테이블 셀의 컨텐츠를 사용자 정의할 수 있다. 이상 예시에선 Ag Grid 내의 컬럼에서 버튼을 렌더링하는 예시다.

cellRenderer 속성의 value는 callback 함수로 이뤄져있다. 그리고 매개변수로 params를 받았고 ICellRenderParams Type 으로 작성했고 params.value의 값은 field 속성에 정의된 full_name을 썼다. 그래서 버튼 누르면 full_name이 출력됐다.

컬럼 이름이 대놓고 field와 동일하게만 되있다. 그러다보니 column명을 확인해보면 Id / Full_name / Html_url / Full_name 으로 Full_name 컬럼이 두 개인 것을 확인 가능. 이를 수정하기 위해선 `headerName` 속성을 활용 가능.

# Material UI Component 이용
shoppinglist 프로젝트 생성
React-TypeScript
App.tsx 초기화
npm install @mui/material@5.14.8
npm install @emotion/react@11.11.1
npm install @emotion/styled@11.11.0

```tsx
import { Container } from '@mui/material'
import { AppBar, Toolbar, Typography } from '@mui/material'
import './App.css'

function App() {


  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6">
            쇼핑리스트 ShoppingList
          </Typography>
        </Toolbar>
      </AppBar>
    </Container>
  )
}
export default App
```
이상에서 주의깊게 봐야할 부분은 각 컴포넌트가 무슨 역할을 하는지다.
Container는 전체 브라우저 화면을 의미하고 AppBar는 상단을 의미함. 그리고 ToolBar는 그 중에서도 nav와 비슷한 역할을 한다. Typography는 글씨 관련 영역을 나타낸다.

이하부턴 실제 shopping list의 기능과 관련된 부븐을 작성할 예정.
당연히 MUI를 도입한 부분이 될 것이기 때문에 일반적인 html + css + js + react의 형태로는 어떻게 작성될 수 있을지 감안한 상태에서 코드를 확인해야 함.

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { useState } from "react";

function AddItem(props) {
  const [ open, setOpen ] = useState(false);

  const handleOpen = () => {
    setOpen(true);
  }
  const handleClose = () => {
    setOpen(false);
  }
  return (
    <>
      
    </>
  )
}
export default AddItem
```
App 컴포넌트 내에 AddItem 컴포넌트를 추가할거다. 근데 todolist할 땐 input창에 button 하나만 있었다. 그리고 github api 가지고 올 때도 그랬었다. 이번엔 Modal 이라고 하는 개념을 추가할거다.

근데 이 Modal을 우리가 처음 배우는건 아니고 1만 시간의 법칙에서 했었다.

폼에 product 와 amount 라는 두 개의 입력 필드와 App 컴포넌트 내에 addItem 함수를 호출하는 버튼을 추가할거다. _App 컴포넌트에 있는 addItem 함수를 호출할 수 있으려면 addItem 컴포넌트를 렌더링할 때 프롭으로 전달_ 해야 한다. 모달 Dialog 컴포넌트 외부에 사용자가 새 쇼핑항목을 입력할 수 있는 모달 폼을 여는 버튼을 추가해둘거다. 해당 버튼은 컴포넌트가 처음 렌더링 될 때 보이는 유일한 요소에 해당할거다.

즉 최초에 open 상태가 false이기 때문에 모달 폼은 보이지 않고 버튼만 보일 것 이라는 의미다.

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { useState } from "react";
import { Item } from "./App";

function AddItem(props) {
  const [ open, setOpen ] = useState(false);
  const [ item, setItem ] = useState<Item>({
    product: '',
    amount: ''
  });

  const handleOpen = () => {
    setOpen(true);
  }

  const handleClose = () => {
    setOpen(false);
  }

  return (
    <>
      <Button onClick={handleOpen}>
        Add Item
      </Button>
      <Dialog open={open} onClose={handleClose}>
        <DialogTitle>
          Add New Item
        </DialogTitle>
        <DialogContent>

        </DialogContent>
        <Button onClick={handleClose}>
          Cancel / 취소
        </Button>
        <Button onClick={addItem}>
          Add / 저장
        </Button>
      </Dialog>
    </>
  )
}

export default AddItem
```
이상에서 일단 주의해서 봐야할 점은 App.tsx에 정의되있는 type인 Item을 가지고 왔다는 점이다. 이 것은 프로젝트의 사이즈가 매우 작기 때문이고 보통은 types.ts 파일에 전체 타입들이 정의되있고 거서 가지고 오게 될거다.

그리고 addItem 함수가 App.tsx에 정의되있지만 AddItem 컴포넌트에서 불러오고 있다. 이 부분에 대해서 의문을 가질 수 있다.
1. AddItem 컴포넌트 내에 addItem 함수를 정의하면 안되는가.
  - App.tsx의 addItem 함수를 확인하면 Item이 추가되고 기존의 items 들을 그대로 

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { useState } from "react";
import { Item } from "./App";

type AddItemProps = {
  addItem: (item: Item) => void;
}

function AddItem(props: AddItemProps) {
  const [ open, setOpen ] = useState(false);
  const [ item, setItem ] = useState<Item>({
    product: '',
    amount: ''
  });

  const handleOpen = () => {
    setOpen(true);
  }

  const handleClose = () => {
    setOpen(false);
  }
  
  // App.tsx의 addItem 함수를 호출하고 item 상태를 전달
  const addItem = () => {
    props.addItem(item);
    // TextField에 있는 내용을 다 지우고 Modal을 닫음
    setItem({product: '', amount: ''});
    handleClose();
  }

  return (
    <>
      <Button onClick={handleOpen}>
        Add Item
      </Button>
      <Dialog open={open} onClose={handleClose}>
        <DialogTitle>
          Add New Item
        </DialogTitle>
        <DialogContent>
          <TextField value={item.product} margin="dense" onChange={e => setItem({...item, product: e.target.value})}
            label="Product/제품명" fullWidth/>
            <TextField value={item.amount} margin="dense" onChange={e => setItem({...item, amount: e.target.value})}
            label="Amount/수량" fullWidth
            />
        </DialogContent>
        <Button onClick={handleClose}>
          Cancel / 취소
        </Button>
        <Button onClick={addItem}>
          Add / 저장
        </Button>
      </Dialog>
    </>
  )
}

export default AddItem
```
이상의 코드에서 props로 전달하는 함수 부분에 주목해야함. 이를 위해 AddItemProps라는 type을 선언했다.

마찬가지로
App.tsx도 확인해야함. 함수를 전달하기 위한 방식이였다.
```tsx
import { Container } from '@mui/material'
import { AppBar, Toolbar, Typography } from '@mui/material'
import './App.css'
import { useState } from 'react'
import AddItem from './AddItem';

export type Item = {
  product: string
  amount: string
}

function App() {
  const [ items, setItems ] = useState<Item[]>([]);
  const addItem = (item: Item) => {
    setItems([item, ...items]);
  };

  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6">
            쇼핑리스트 ShoppingList
          </Typography>
        </Toolbar>
      </AppBar>
      <AddItem addItem={addItem} />
    </Container>
  )
}
export default App
```
그렇다면 현재까지 작성한 것을 기준으로 했을 때 App.tsx에 있는 items 상태가 업데이트 된다는 것은 확인할 수 있다.

근데 그 업데이트된 items를 보여주지 못하고 있네.

그럼 업데이트 된 items의 결과를 보여주는 return부분에서의 코드가 있어야 할 것 같다.

```tsx
import { Container } from '@mui/material'
import { AppBar, Toolbar, Typography } from '@mui/material'
import { List, ListItem, ListItemText } from '@mui/material'
import './App.css'
import { useState } from 'react'
import AddItem from './AddItem';

export type Item = {
  product: string
  amount: string
}

function App() {
  const [ items, setItems ] = useState<Item[]>([]);
  const addItem = (item: Item) => {
    setItems([item, ...items]);
  };

  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6">
            쇼핑리스트 ShoppingList
          </Typography>
        </Toolbar>
      </AppBar>
      <AddItem addItem={addItem} />
      <List>
        {
          items.map((item, index) =>
            <ListItem key={index} divider>
              <ListItemText
                primary={item.product}
                secondary={item.amount}/>
            </ListItem>
          )
        }
      </List>
    </Container>
  )
}

export default App
```
이상에서 확인해야 하는 점은 기본적으로 items 상태를 업데이트 하는 부분이 어느 부분에 작성되야 하는가 다. 구조는 현재
App
  ↆ
AddItem
컴포넌트 구조로 되있다. 즉 App 컴포넌트에 items 결과값을 표시할 것이냐 AddItem 컴포넌트에 표시할 것이냐 1/2 확률이라고 볼 수 있다.

심플하게 생각해봤을 때 items 상태가 정의된 곳이 어디게
App
그래서 App에 결과값 표시했다.

List 컴포넌트를 App 컴포넌트 내에서 렌더링 했다. 지금 현재까지 MUI를 보면 위계가 잡혀있다는 것을 알 수 있다.
List -> ListItem -> ListItemText
ul -> li
List 내에서 map() 함수를 활용해 ListItem 컴포넌트를 생성했다.(ul 내부에서 map 함수 써서 li를 만든 것과 동일) 배열이기 때문에 key 프롭이 요구되는 것도 동일.

그리고 `<ListItem key={index} divider>` 에서 보면 divider 라는 속성이 있는데 얜 각 항목 끝부분에 구분선을 가지고 온다.

다음에 ListItemText에서 기본 텍스트로 product를 표시하고 보조 텍스트로 amount를 표시했다. 각각 primary / secondary로 쓰였다. MUI에서 자주 쓰이는 속성이다.

또한 button의 스타일이 있는데 variant="outlined/text/contained" 로 쓸 수 있다.

이상의 MUI 라이브러리를 사용하면 리액트 앱에서 일관되게 디자인을 하는 것이 가능하다. 그리고 좋은 점은 프로젝트를 찍어낼 때 CSS를 고려할 필요성이 덜 하다는 점이다.

하지만 기본값이 정해져있는만큼 커스터마이징을 하기 위해선 emotion이나 tailwind를 고려할 필요도 있다.

밥먹고 React Router를 활용해 라우팅 관리 하는 법을 수업함.

# React Router
routerapp project생성 / React / TypeScript
npm install
npm install react-router-dom@6
App.tsx 초기화
Home.tsx 생성, 초기화
Contact.tsx 생성, 초기화

React Router란 URL을 기반으로 특정 컴포넌트를 렌더링할지 정의할 수 있는 방식

react-router-dom 라이브러리는 라우팅을 구현하는데 이용되는 컴포넌트들을 제공함.
1. BrowserRouter : 웹 기반 애플리케이션을 위한 라우터
2. Route : 주어진 위치가 일치하면 정의된 컴포넌트를 렌더링
이하는 Route 컴포넌트의 예시인데, element 속성은 사용자가 path 프롭에 정의된 contact 엔드포인트로 이동할 때 렌더링 되는 컴포넌트를 정의함. 경로는 현재 위치를 기준으로 상대 경로를 작성함.
`<Route path="contact" element={<Contact />} />`
혹은 이하와 같이 path 속성 끝에 * 와일드 카드를 이용하는 것도 가능.
`<Route path="/contact/*" element={<Contact />} />`
그럼 contact / mike 혹은 contact/1 등의 엔드포인트들에 전부 다 Contact 컴포넌트가 렌더링됨.
또한 Route 컴포넌트는 여러 Route 컴포넌트를 감싸는 것이 가능. 이를 위해 Link 컴포넌트는 애플리케이션에 대한 탐색 기능을 제공하는데 이하의 예시는 Contact 링크를 표시하며 해당 링크를 클릭했을 때 `/contact` 엔드포인트로 이동함.
`<Link to="/contact">Contact</Link>`

```tsx
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom'
import Home from './Home'
import Contact from './Contact'
import './App.css'
import PageNotFound from './PageNotFound'
import ContactSeoul from './ContactSeoul'
import ContactBusan from './ContactBusan'

function App() {


  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Home</Link>{' | '}
        <Link to="/contact">Contact</Link>
      </nav>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/contact" element={<Contact />}/>
        <Route path="/seoul" element={<ContactSeoul />}/>
        <Route path="/busan" element={<ContactBusan />}/>
        <Route path="*" element={<PageNotFound />}/>
        </Routes>
    </BrowserRouter>
  )
}

export default App

// Contact.tsx
import { Link } from "react-router-dom"

function Contact() {
  return (
    <>
      <>
        <h3>Contact Us !</h3>
        <nav>
          <Link to="/seoul">서울 지점</Link>{' | '}
          <Link to="/busan">부산 지점</Link>
        </nav>
      </>
    </>
  )
}

export default Contact
```
`<Outlet />` : 중첩 라우트(Nested Routes)를 렌더링하기 위해 사용하는 일종의 자리 표시자(placeholder)이다.

그니까 OUtlet 컴포넌트가 있는 장소에 해당 자식 컴포넌트를 불러내주세요 라는 의미가 된다.

그럼 이상의 코드에서 봤던 것 처럼 App.tsx의 `<Route path="contact" element={<Contact /> }>`의 내부에 seoul과 busan 엔드포인트를 지정했고 거기에 ContactSeoult과 ContactBusan을 이미 명시해뒀다. 그렇기 때문에 Contact 컴포넌트 내에서 다시 ContactSeoul 및 ContactBusan을 명시하는 것이 아니라 `<Outlet />` 컴포넌트를 통해 불러온다 생각하면 됨.

이상의 라이브러리를 이용할 경우 컴포넌트들이 하나의 URL(예를 들어 localhost:5173) 만 가지는 것이 아니라 각각의 다른 URL을 가지도록 통제하여 필요한 부분만을 렌더링 할 수 있도록 한다.

# 금일 현재까지의 학습 내용 요약
1. 3rd party 컴포넌트들을 학습했다.
  - react-date-picker는 그냥 설치하는 방법 보여줌.
  - AgGrid 를 이용했다.
    - 테이블을 대체하는 컴포넌트
      - filter, sort, column 정의와 관련된 부분을 학습함.
  - MUI 컴포넌트
    - 이상에서 중요한 것은 각각의 HTML 태그에 해당하는 컴포넌트들이 존재한다는 점이다.
      - `<input>` 태그를 대체하는 것은 `<TextField>` 인 등
      - 내부에 MUI 자체 property가 있기 때문에 학습 필요성이 있다.
      - 귀찮게 하나하나 학습할거면 왜 쓰냐 싶은데 이게 CSS 보다 훨씬 쉬워서 그럼.
  - react-router-dom
    - SPA 상에서 하나의 URL이 아니라 다수의 URL을 다루는 방식을 학습했다.
    - 조건부 렌더링이 if문이나 삼항 연산자를 쓰는 것 뿐만 아니라 내부의 URL을 기준으로 서로 다른 컴포넌트를 렌더링 할 수 있도록 하는 방식이였다.

외부 라이브러리를 다루는 현재 시점에선 수업 자체보단 공식 문서의 활용이 매우 중요함. 프로젝트 때 어떤 라이브러리를 다루게 될 지 모르니까.

# Full Stack 개발 - 스프링부트 RESTful API 웹 서비스를 위한 프론트엔드
## UI prototype
1. 데이터 베이스의 자동차를 테이블에 나열하고 페이징, sorting, filtering 기능을 구현할거다. - AG Grid 를 써서.
2. 데이터 베이스에 새 차량을 추가할 수 있는 모달 폼을 여는 버튼을 구현할거다. - MUI 사용
3. 차량 테이블의 각 행에 자동차를 편집하거나 데이터베이스에서 삭제하는 버튼을 구현할거다. - AG Grid에 있었는데 거기에 버튼을 클릭했을 때 특정 함수가 호출되고 그게 백엔드로 전달 -> DB로 들어가서 PUT 혹은 DELETE 메서드를 실행시킬거다.
4. CSV 파일로 변형해 내려받기가 가능한 링크 혹은 버튼 구현해볼까 한다.

## FrontEnd React 프로젝트 생성
carfront project 생성 React / TypeScript
npm install
npm install @emotion/react@11.14.0
npm install @emotion/styled@11.14.0
npm install @mui/material@5.17.1
npm install @tanstack/react-query@4.36.1
npm install axios@1.9.0
App.tsx 초기화
npm run dev
git add .
git commit -m "feat: carfront project creation"
git push
