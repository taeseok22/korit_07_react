# Back-Front Connection

# 수업 계획
1. C 관련 부분 MUI 컴포넌트로 대체
2. U 부분 구현
3. Button 및 MUI Icons 도입
4. Frontend 로그인 관련 로직

## 코드 리팩토링 관련
New Car 버튼을 클릭했을 때 Modal 이 나오면서 빈 input 태그들이 뜬다. 여기에 정보를 입력할 수 있는 상태다.

근데 각 row의 맨 마지막 컬럼으로 Edit 버튼을 추가해서 일부 수정을 가능하게끔 할 예정. 그리고 이때도 Modal이 뜨게끔 할거다.

그럼 New Car에서 사용하는 Modal을 Edit에서도 동일하게 쓸 수 있을 것 같다. 우리 블로그를 작성할 때 새로 발행하기 하면 빈 양식으로 뜨는데 수정하기 하면 똑같은 양식 튀나오지만 내용 그대로 나오는 것과 동일하다고 할 수 있다.

components 폴더 내에 CarDialogContent.tsx 생성

```tsx
import { ChangeEvent } from "react";
import { Car } from "../types";

type DialogFormProps = {
  car: Car;
  handleChange: (event: ChangeEvent<HTMLInputElement>) => void;
}

function CarDialogContent({ car, handleChange }: DialogFormProps) {
  return (
    <>
      
    </>
  )
}

export default CarDialogContent;
```
현재 CarDialogContent 컴포넌트를 초기화했다.
현재의 목표는 New Car 폼의 TextField를 렌더링하는 새 컴포넌트를 만들어서 Edit 폼에도 사용하는거다.

그래서 TextField에 해당하는 부분을 자체 컴포넌트로 만들기 위해 CarDialogContent를 새로 만들었다. 그리고 props를 이용해 컴포넌트에 car 객체와 handleChange 함수를 전달해야 한다.(AddCar 컴포넌트에 정의돼있다.) 이를 위해 DialogFormProps type을 정의해뒀다. 얘를 types.ts로 분리하지 않은 이유는 얘를 Edit에 쓸지 안쓸지 몰라서다.

## 수정 기능 추가
Edit 버튼의 경우 위치가 New Car와 동일해선 안됨. {id}에 맞는 부분을 수정해야 하기 때문에 각 row옆에다가 Edit 버튼을 추가할거다.

```tsx
import { ChangeEvent, useState } from "react";
import { Car, CarResponse } from "../types";
import { Dialog, DialogActions, DialogTitle } from "@mui/material";
import CarDialogContent from "./CarDialogContent";

type FormProps = {
  cardata: CarResponse;
}

function EditCar({ cardata }: FormProps) {
  const [open, setOpen] = useState(false);
  const [car, setCar] = useState<Car>({
    brand: '',
    model: '',
    color: '',
    registrationNumber: '',
    modelYear: 0,
    price: 0
  });

  const handleClickOpen = () => {
    setOpen(true);
    // Modal이 열렸을 때 특정 id 값에 맞는 정보를 불러오면 좋겠다. 그래서 AddCar에서의 handleClickOpen()과 코드라인의 차이가 생김.
    // setCar({
    //   brand: cardata.brand,
    //   model: cardata.model,
    //   color: cardata.color,
    //   registrationNumber: cardata.registrationNumber,
    //   modelYear: cardata.modelYear,
    //   price: cardata.price
    // });
  }
  const handleClickClose = () => {
    setOpen(false);
  }
  const handleSave = () => {
    setOpen(false);
  }
  // AddCar.tsx의 handleChange와 동일
  const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
    setCar({ ...car, [event.target.name]: event.target.value });
  }

  return (
    <>
      <button onClick={handleClickOpen}>Edit</button>
      <Dialog open={open} onAbort={handleClickClose}>
        <DialogTitle>Edit Car</DialogTitle>
        <CarDialogContent car={car} handleChange={handleChange}/>
        <DialogActions>
          <button onClick={handleSave}>Save | 저장</button>
          <button onClick={handleClickClose}>Cancel | 취소</button>
        </DialogActions>
      </Dialog>
    </>
  )
}

export default EditCar;
```
이상의 EditCar 컴포넌트를 Carlist 컴포넌트에 집어넣었다. 특정 id값을 받아내기 위해 GridColDef 부분에 새로 컬럼 정의해줬고 renderCell을 이용해 이상의 컴포넌트를 불러냈다.

이부분까지 작성했을 때 frontend 상에서 edit 버튼이 생기고 그걸 클릭했을 때 Modal창이 뜬다는 것을 확인 가능. 그 모달 창은 CarDialogContent 컴포넌트고 AddCar에서 사용했던 것과 동일하기 때문에 컴포넌트가 재사용성이 있다는 점을 확인 가능.

차이점이 있다면 각각의 input 태그 내에 AddCar 컴포넌트에선 전부 값이 비워져있던 반면에 EditCar에선 어떤 row를 클릭했는지에 따라 값이 서로 다르게 input 태그 내에 들가있었다.

이는 마찬가지로 renderCell이 (params)를 매개변수로 갖기 때문. params.row를 하게 되면 테이블 내의 각 row들을 지칭하게됨.

이제 우리가 고려해야 하는 부분은 브라우저 상에서 수정된 자동차 정보를 백엔드로 보내줘야 한다는 점이다. http://localhost:8080/api/cars/{id}로 PUT 요청을 보내게 될거다. 링크 삭제할 때 href 값을 가져왔었기 때문에 동일 기능을 한다는 것을 알 수 있다.

차이점이 있다면 deleCar()는 id 값만 보내면 되는 반면에 updateCar()의 경우는 수정할 id 값과 수정 내용이 전달되야 하기 때문에 매개변수 개수가 달라짐. 이 부분도 backend에서의 CarController를 확인하면 된다(cardatabase4 기준임. 2엔 없다.)

여기 요청의 경우엔 내용이 필요하기 때문에 addCar()에서와 마찬가지로 `Content-Type`: 'application/json' headers가 필요.

새로운 자료형 정의했다.
```ts
export type CarEntity = {
  car: Car;
  url: string;
}
```
이후 carapi.ts에서 함수를 생성해 export 시키게 될 것이고 그 함수는 EditCar 컴포넌트에서 사용하게 될 예정.
```ts
// carapi.ts
export const updateCar = async (carEntity: CarEntity): Promise<CarResponse> => {
  const response = await axios.put(carEntity.url, carEntity.car, {
    headers: {
      'Content-Type': 'application/json',
    },
  });

  return response.data;
}
```
이상의 코드는 addCar() 함수와 비슷한 부분들이 있다. 하지만 axios.put() 요청에서의 첫번째 argument가 변수를 통해 불러와진다는 점에서의 차이점이 있다. 왜냐면 애초에 차량 정보가 DB에 저장되있기 때문에 endpoint가 id값까지 생성되있다. 그리고 우린 이것을 삭제 할 때 alert()을 통해 href값을 가지고 올 수 있다는 것을 확인했었다. 그래서 굳이 `${import.meta.env.VITE_API_URL}/api/cars/${car.id}`와 같은 식으로 작성할 필요가 없다.

## CSV로 데이터 내보내기
MUI 데이터 그리드에서 CSV(Comma Seprated Value) 데이터 내보내기 기능을 지원하기 때문에 추가 라이브러리의 설치 필요가 없다.

그럼 위에서 데이터 그리드에서 가지고 올거라고 했으니까 기본적으로 Carlist 컴포넌트에서 작성할 것이라고 알 수 있겠네.

버전이 x-data-grid가 7 버전 이후부턴 GridToolbar를 지원 안해서 패키지 삭제 실습 해볼게

터미널
npm uninstall @mui/x-data-grid
그다음 특정 버전 명시해 설치하는 방법은 이미 했다.
npm install @mui/x-data-grid@6.16.2

git add .
git commit -m "feat: x-data-grid-version control 6.16.2"
git push

# MUI 활용 프론트엔드 꾸미기
1. Button 컴포넌트        - AddCar / EditCar 컴포넌트의  button을 Button으로 바깠다.
2. TextField 컴포넌트
3. Icon / IconButton

icon 도입
npm install @mui/icons-material@5.17.1
이상의 icon 패키지는 Delete 버튼을 아이콘 버튼 형태로 사용하기 위해 도입했다.
아이콘 종류가 많으므로 레퍼런스
https://mui.com/material-ui/material-icons
이상으로 들가면 import 해올 아이콘 목록이 있다. 도입 방식은
MUI와 관련된 공식 문서기 때문에 혹시 팀 프로젝트 중에 MUI를 기준으로 CSS를 꾸밀 생각이 있다면 즐겨찾기 해두는거 추천.

```tsx
function CarDialogContent({ car, handleChange }: DialogFormProps) {
  return (
    <DialogContent>
      <Stack spacing={2} sx={{ mt: 1 }}>
        <TextField label="Brand" name="brand" value={car.brand} onChange={handleChange} /><br />
        <TextField label="Model" name="model" value={car.model} onChange={handleChange} /><br />
        <TextField label="Color" name="color" value={car.color} onChange={handleChange} /><br />
        <TextField label="registrationNumber"  name="registrationNumber"  value={car.registrationNumber} onChange={handleChange} /><br />
        <TextField label="Year" name="modelYear"  value={car.modelYear} onChange={handleChange} /><br />
        <TextField label="Price" name="price"  value={car.price} onChange={handleChange} /><br />
      </Stack>
    </DialogContent>
```
Stack 컴포넌트를 보면 객체 형태로 값을 집어넣었다. 반면에 TextField의 경우엔 string을 그대로 넣었다. 해당 부분에 관련한 것은 팝업을 확인하거나 혹은 하드코딩이 가능한지에 관한 체크 필요.

그리고 MUI의 속성들의 경우 문제점이 축약어를 너무 많이 쓴다는거다. 그래서 이상의 공식 문서에서 컴포넌트의 속성에 대해 읽어볼 필요가 있다.

예를 들어

spacing의 경우 Stack 컴포넌트 내에 있는 자식 컴포넌트들끼리의 간격을 나타냄. 얜 full word인데 mt는 먼말인지 모를 확률이 높은데 margin-top의 축약어다.

# Frontend 애플리케이션 보호
현재까지의 상황에서 Backend의 SecurityConfig를 확인하면 전체 HTTP 요청에 대해 전부 permitAll()이 적용되있는 상태다. 즉 CommandLineRunner를 통해 user/user, admin/admin을 집어넣어놨는데도 불구하고 아예 써먹지 못하고 있는 상황이라 할 수 있다.

이제 다시 Backend 설정을 되돌리고, Frontend 상에서 JWT 인증을 이용한 것을, 프론트엔드에서 구현하는 방법을 학습할 예정입니다. 그럴려면 Login 관련 컴포넌트가 추가적으로 필요하겠네요. 그리고 user 관련 정보를 CRUD 할 수도 있어야하고, 로그아웃도 할 수 있어야 합니다.

## 백엔드 SecurityConfig 수정(원상 복구)

## 프론트엔드 보호 과정
1. Login 컴포넌트 생성
Login.tsx 생성

```tsx
import axios from "axios";
import { useState } from "react";

type User = {
  username: string;
  password: string;
}
function Login() {
  const [ user, setUser] = useState<User>({
    username: '',
    password: ''
  });

  const [ isAuthenticated, setAuth] = useState(false);

  return (
    <>
    </>
  )
}

export default Login;
```
인증엔 두 가지 상태가 요구됨
1. 자격 증명(username / password)
2. 인증 상태를 나타내는 boolean 값

이후 MUI를 바로 적용해서 TextField / Button 등을 이용해 return을 작성해서 프로토 타입을 최대한 빠르게 뽑아내겠다.

```tsx
// Login.tsx
import { Button, TextField, Stack } from "@mui/material";
import axios from "axios";
import { ChangeEvent, useState } from "react";


type User = {
  username: string;
  password: string;
}
function Login() {
  const [ user, setUser] = useState<User>({
    username: '',
    password: ''
  });

  const [ isAuthenticated, setAuth] = useState(false);

  const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
    setUser({...user, [event.target.name]: event.target.value});
  }
  const handleLogin = async () => {
    // 일부러 템플릿 리터럴로 안썼다.
    axios.post(import.meta.env.VITE_API_URL + "/login", user, {
      headers: {
        'Content-Type': 'application/json',
      }
    })
    .then(response => {
      const jwtToken = response.headers.authorization;
      if(jwtToken !== null) {
        sessionStorage.setItem("jwt", jwtToken);
        setAuth(true);
      }
    })
    .catch(error => {
      console.log(error);
    });
    // axios.post(`${import.meta.env.VITE_API_URL}/api/login`, user, {
    //   headers: {
    //     'Content-Type': 'application/json',}
    //   })
  }

  return (
    <Stack spacing={2} alignItems={"center"} mt={2}>
      <TextField
        name="username"
        label="Username"
        onChange={handleChange}
      />
      <TextField
        name="password"
        label="Password"
        type="password"
        onChange={handleChange}
      />
      <Button
      variant="contained"
      color="primary"
      onClick={handleLogin}
      >
        Login
      </Button>
    </Stack>
  )
}

export default Login;
```
현재까지의 상황에서 isAuthenticated가 false면 Login 컴포넌트를 띄워야 하고 isAuthenticated가 true 값이라면 Carlist 컴포넌트를 가지고 와야 한다.

그러면 이하에서 요구되는 코드는 조건부 렌더링에 해당함.

현재 상황에서 우리는 마치 App 컴포넌트의 하위 컴포넌트로 Login과 Carlist가 있다 생각할 수도 있다.

근데 얜 좀 문제가 있는게 App 컴포넌트에 isAuthenticated 상태를 정의한게 아니라는 점이다.

그럼 ContextAPI를 도입하지 않는 이상 Login 컴포넌트에서 정의한 상태를 상위 컴포넌트로 보낼 수가 없으니까 코드 자체가 틀려먹었거나 아니면 ContextAPI를 도입해야 할 것 같다.

귀찮아서 안할건데 대신 Carlist를 Login 컴포넌트의 하위로 보낼거다.
